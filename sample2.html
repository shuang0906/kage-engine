<!doctype html>
<html>

<head>
  <title>KAGE engine sample</title>
  <style>
    html {
      background-color: mintcream;
    }

    #canvas,
    #svg {
      display: inline-block;
      border: 1px #ccc solid;
    }

    svg {
      display: block;
    }

    #data_area {
      width: 30em;
      height: 32em;
    }
  </style>
  <script type="text/javascript" src="2d.js"></script>
  <script type="text/javascript" src="buhin.js"></script>
  <script type="text/javascript" src="curve.js"></script>
  <script type="text/javascript" src="kage.js"></script>
  <script type="text/javascript" src="kagecd.js"></script>
  <script type="text/javascript" src="kagedf.js"></script>
  <script type="text/javascript" src="polygon.js"></script>
  <script type="text/javascript" src="polygons.js"></script>

  <script type="module">
    Kage.prototype.makeGlyph = function (polygons, name) {
      const glyphData = this.kBuhin.search(name);
      const adjusted = this.adjustStrokes(this.getEachStrokes(glyphData));
      for (let i = 0; i < adjusted.length; i++) {
        dfDrawFont(this, polygons,
          adjusted[i][0],
          adjusted[i][1],
          adjusted[i][2],
          adjusted[i][3],
          adjusted[i][4],
          adjusted[i][5],
          adjusted[i][6],
          adjusted[i][7],
          adjusted[i][8],
          adjusted[i][9],
          adjusted[i][10]);
      }
    };

    //import { Kage, Polygons } from "https://unpkg.com/@kurgm/kage-engine@0.6.0/dist/kage.min.mjs";

    function idsToKageAutoLayout(ids) {
      const idMap = {
        "â¿°": "LR", // å·¦å³
        "â¿±": "TB", // ä¸Šä¸‹
        "â¿²": "LLR", // å·¦ä¸­å³
        "â¿³": "TTB"  // ä¸Šä¸­ä¸‹
      };

      function recurse(expr) {
        // æ‹¬å·ä¿æŠ¤ï¼ˆç”¨äºåµŒå¥—ï¼‰
        if (!Object.keys(idMap).some(op => expr.includes(op))) {
          return expr.trim().toLowerCase();
        }

        const type = expr[0];
        const parts = splitIds(expr.slice(1));

        const children = parts.map(recurse); // é€’å½’è½¬æ¢æ¯ä¸ªå­éƒ¨ä»¶
        if (type === "â¿°") {
          return `99:0:0:0:0:100:200:${children[0]}$99:0:0:100:0:200:200:${children[1]}`;
        } else if (type === "â¿±") {
          return `99:0:0:0:0:200:100:${children[0]}$99:0:0:0:100:200:200:${children[1]}`;
        } else if (type === "â¿²") {
          return `99:0:0:0:0:66:200:${children[0]}$99:0:0:66:0:133:200:${children[1]}$99:0:0:133:0:200:200:${children[2]}`;
        } else if (type === "â¿³") {
          return `99:0:0:0:0:200:66:${children[0]}$99:0:0:0:66:200:133:${children[1]}$99:0:0:0:133:200:200:${children[2]}`;
        } else {
          throw new Error(`Unsupported IDS structure: ${type}`);
        }
      }

      // å°å·¥å…·ï¼šæ”¯æŒåµŒå¥—æ‹¬å·å®‰å…¨åˆ‡å‰²å­ç»“æ„
      function splitIds(s) {
        const result = [];
        let depth = 0, current = "";
        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          if (ch === "." && depth === 0) {
            result.push(current);
            current = "";
          } else {
            if (ch === "(") depth++;
            if (ch === ")") depth--;
            current += ch;
          }
        }
        if (current) result.push(current);
        return result;
      }

      return recurse(ids);
    }


    async function expandGlyph(name, kage, depth = 0) {
      if (kage.kBuhin.search[name]) return;

      const res = await fetch(`https://glyphwiki.org/api/glyph?name=${name}`);
      const json = await res.json();
      if (!json || !json.data) {
        console.warn(`âš ï¸ éƒ¨ä»¶ ${name} ä¸å­˜åœ¨`);
        return;
      }

      const data = json.data.trim();
      const subComponents = extractComponents(data);

      for (const comp of subComponents) {
        await expandGlyph(comp, kage, depth + 1);
      }

      kage.kBuhin.push(name, data);
    }


    function extractComponents(glyphData) {
      const lines = glyphData.split("$");
      const componentNames = [];

      for (const line of lines) {
        const parts = line.split(":");
        if (parts[0] === "99" && parts[7]) {
          const raw = parts[7].split(":")[0]; // å»æ‰åç¼€å‚æ•°
          componentNames.push(raw);
        }
      }

      return [...new Set(componentNames)];
    }

    function idsToKage(ids) {
      const type = ids[0];
      const parts = ids.slice(1).split(".");

      if ((type === "â¿°" || type === "â¿±") && parts.length !== 2)
        throw new Error(`${type} ç»“æ„å¿…é¡»æ˜¯ä¸¤ä¸ªå­éƒ¨ä»¶`);
      if ((type === "â¿²" || type === "â¿³") && parts.length !== 3)
        throw new Error(`${type} ç»“æ„å¿…é¡»æ˜¯ä¸‰ä¸ªå­éƒ¨ä»¶`);

      const mapped = parts.map(p => p.trim().toLowerCase());

      if (type === "â¿±") {
        return `99:0:0:0:0:200:100:${mapped[0]}$99:0:0:0:100:200:200:${mapped[1]}`;
      } else if (type === "â¿°") {
        return `99:0:0:0:0:10:200:${mapped[0]}$99:0:0:100:0:200:200:${mapped[1]}`;
      } else if (type === "â¿³") {
        return [
          `99:0:0:0:0:200:66:${mapped[0]}`,
          `99:0:0:0:66:200:133:${mapped[1]}`,
          `99:0:0:0:133:200:200:${mapped[2]}`
        ].join("$");
      } else if (type === "â¿²") {
        return [
          `99:0:0:0:0:66:200:${mapped[0]}`,
          `99:0:0:66:0:133:200:${mapped[1]}`,
          `99:0:0:133:0:200:200:${mapped[2]}`
        ].join("$");
      } else {
        throw new Error("ä¸æ”¯æŒçš„ç»“æ„ç±»å‹ï¼š" + type);
      }
    }

    async function updateGlyph() {
      const kage = new Kage();
      const polygons = new Polygons();
      kage.kShotai = kage.kMincho;

      const ids = document.getElementById("data_area").value.trim();
      console.log("IDS è¡¨è¾¾å¼ï¼š", ids);

      const kageData = idsToKageAutoLayout(ids);
      console.log("ç”Ÿæˆçš„ç»“æ„å¼ KAGE dataï¼š", kageData);

      const componentNames = extractComponents(kageData);
      for (const name of componentNames) {
        await expandGlyph(name, kage);
      }

      // â‘¢ æ³¨å†Œä¸€ä¸ªä¸´æ—¶ glyph åï¼ˆç”¨ IDS å­—ç¬¦ä¸²ä¹Ÿå¯ä»¥ï¼‰
      const glyphName = "custom-glyph";
      kage.kBuhin.push(glyphName, kageData);

      const glyphData = kage.kBuhin.search(glyphName);

      kage.makeGlyph(polygons, glyphName);
      

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgb(0, 0, 0)";

      for (let i = 0; i < polygons.array.length; i++) {
        ctx.beginPath();
        ctx.moveTo(polygons.array[i].array[0].x, polygons.array[i].array[0].y);
        for (let j = 1; j < polygons.array[i].array.length; j++) {
          ctx.lineTo(polygons.array[i].array[j].x, polygons.array[i].array[j].y);
        }
        ctx.closePath();
        ctx.fill();
      }

      document.getElementById("svg").innerHTML = polygons.generateSVG(false);
    }

    document.addEventListener("DOMContentLoaded", () => {
      const dataArea = document.getElementById("data_area");
      dataArea.addEventListener("input", updateGlyph);

      const m = location.hash.match(/^#kage=([^&]+)/);
      if (m) {
        dataArea.value = decodeURIComponent(m[1]).split("$").join("\n");
      }

      updateGlyph();
      Kage.prototype.adjustStrokes = function (arr) {
        console.log("ğŸŒ€ è°ƒç”¨äº† adjustStrokesï¼Œstroke æ•°é‡ï¼š", arr.length);
        return arr;
      };
    });




  </script>
</head>

<body>
  <div>
    <canvas id="canvas" width="200" height="200"></canvas>
    <div id="svg"></div>
  </div>
  <div>
    <textarea id="data_area">â¿°u5973.u5b50</textarea>
  </div>
</body>

</html>